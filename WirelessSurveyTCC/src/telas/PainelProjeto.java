/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package telas;
/*
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
*/

import ferramentas.GnuPlotComandos;
import ferramentas.HeatMapPanel;
import static ferramentas.HeatMapPanel.HEIGHT;
import static ferramentas.HeatMapPanel.WIDTH;
import ferramentas.JPanelMeuEstilo;
import ferramentas.PintaPontos;
import ferramentas.PontoMedicao;
import java.awt.BasicStroke;
import principal.TelaPrograma;
import java.awt.image.BufferedImage;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.List;
import java.awt.Stroke;
//import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
//import java.beans.PropertyChangeListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
//import java.io.DataInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Vector;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.BorderFactory;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
//import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
/*
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
*/
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileView;
import sun.awt.image.BufferedImageGraphicsConfig;

/**
 *
 * @author vinicius023
 */
public class PainelProjeto extends javax.swing.JPanel {

    /**
     * Creates new form PainelProjeto
     */
    
    private static boolean inicio=true;
    
    public final boolean PROGRAMA_EXECUTANDO = true;
    public boolean ATUALIZA = false;
    public long INTERVALO_ATUALIZACAO = 6000;
    public long INTERVALO_MEDICAO = 1000;
    
    //Vector<PontoMedicao> pontosColeta;
    TelaPrograma pai;
    Calendar data = new GregorianCalendar();
    private JFileChooser chooser;
    private File arquivoCaptura;
    
    private int xAnterior;
    private int yAnterior;
    protected Vector<Integer[]> listPontos = new Vector<>();

    public ArquivoMedicoesHandler manipuladorArquivoMedicoes;
    
    public PainelProjeto() {
        //listPontos = new Vector<>();
        //pontosColeta = new Vector<PontoMedicao>();
        
        initComponents();
        initMapaAmbienteChooser();
        
        jLabelMapaAmbiente.addMouseListener(new MouseTratadorClique());    
        jButtonAddMap.addActionListener(new FileOpenListener(this));    
        //jPanelMapa.add( new PintaPontos(jPanelMapa) );
        
        //initArquivoSaida(null);
        
        // CRIA AS THREADS QUE ITAO ATUALIZAR DE TEMPOS EM TEMPOS A GUI
        (new Thread( new AtualizadorHeatmap() )).start();
        (new Thread( new AtualizadorPontosMedicao() )).start();
        // SÓ DEPOIS QUE TUDO ESTIVER PRONTO LIBERA AS THREADS PARA DESENHAR
        //ATUALIZA = true;
        
    }
    
    private void initMapaAmbienteChooser() {

        chooser = new JFileChooser();
        // definir extenções de imagens visiveis
        final ExtensionFileFilter filter = new ExtensionFileFilter();
       
        filter.addExtension("png");
        filter.setDescription("Image files");
        chooser.setFileFilter(filter);
        chooser.setAccessory(new ImagePreviewer(chooser));
        chooser.setFileView(new FileIconView(filter, new ImageIcon("palette.gif")));
    }

    /**
     * @return the pai
     */
    public TelaPrograma getPai() {
        return pai;
    }

    /**
     * @param telaPrograma the pai to set
     */
    public void setPai(TelaPrograma telaPrograma) {
        this.pai = telaPrograma;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelImagem = new javax.swing.JPanel();
        jPanelDesenhaPontos = new javax.swing.JPanel();
        jLabelPontos = new javax.swing.JLabel();
        jPanelHeatMap = new javax.swing.JPanel();
        jLabelHeatmap = new javax.swing.JLabel();
        jPanelMapa = new javax.swing.JPanel();
        jLabelMapaAmbiente = new javax.swing.JLabel();
        jPanelFiltros = new javax.swing.JPanel();
        jLabelFiltroOpcoes = new javax.swing.JLabel();
        jComboBoxFiltrosOpcoes = new javax.swing.JComboBox<>();
        jPanelBotoes = new javax.swing.JPanel();
        jButtonSave = new javax.swing.JButton();
        jButtonAbort = new javax.swing.JButton();
        jButtonAddMap = new javax.swing.JButton();
        jButtonFinishProject = new javax.swing.JButton();

        setPreferredSize(new java.awt.Dimension(1280, 720));
        setLayout(new java.awt.BorderLayout());

        jPanelImagem.setBackground(new java.awt.Color(64, 139, 215));
        jPanelImagem.setMinimumSize(new java.awt.Dimension(1000, 600));
        jPanelImagem.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelImagem.setLayout(null);

        jPanelDesenhaPontos.setBackground(new java.awt.Color(149, 159, 220));
        jPanelDesenhaPontos.setFocusable(false);
        jPanelDesenhaPontos.setMaximumSize(new java.awt.Dimension(1000, 600));
        jPanelDesenhaPontos.setMinimumSize(new java.awt.Dimension(1000, 600));
        jPanelDesenhaPontos.setOpaque(false);
        jPanelDesenhaPontos.setLayout(null);

        jLabelPontos.setFont(new java.awt.Font("Noto Sans", 1, 24)); // NOI18N
        jLabelPontos.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelPontos.setAlignmentY(0.0F);
        jLabelPontos.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        jLabelPontos.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jLabelPontos.setMaximumSize(new java.awt.Dimension(1000, 600));
        jLabelPontos.setMinimumSize(new java.awt.Dimension(1000, 600));
        jLabelPontos.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelDesenhaPontos.add(jLabelPontos);
        jLabelPontos.setBounds(0, 0, 1000, 600);

        jPanelImagem.add(jPanelDesenhaPontos);
        jPanelDesenhaPontos.setBounds(0, 0, 1000, 600);

        jPanelHeatMap.setBackground(new java.awt.Color(149, 159, 220));
        jPanelHeatMap.setFocusable(false);
        jPanelHeatMap.setMaximumSize(new java.awt.Dimension(1000, 600));
        jPanelHeatMap.setMinimumSize(new java.awt.Dimension(1000, 600));
        jPanelHeatMap.setOpaque(false);
        jPanelHeatMap.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelHeatMap.setLayout(null);

        jLabelHeatmap.setFont(new java.awt.Font("Noto Sans", 1, 24)); // NOI18N
        jLabelHeatmap.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelHeatmap.setAlignmentY(0.0F);
        jLabelHeatmap.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        jLabelHeatmap.setMaximumSize(new java.awt.Dimension(1000, 600));
        jLabelHeatmap.setMinimumSize(new java.awt.Dimension(1000, 600));
        jLabelHeatmap.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelHeatMap.add(jLabelHeatmap);
        jLabelHeatmap.setBounds(0, 0, 1000, 600);

        jPanelImagem.add(jPanelHeatMap);
        jPanelHeatMap.setBounds(0, 0, 1000, 600);

        jPanelMapa.setBackground(new java.awt.Color(149, 159, 220));
        jPanelMapa.setFocusable(false);
        jPanelMapa.setMaximumSize(new java.awt.Dimension(1000, 600));
        jPanelMapa.setMinimumSize(new java.awt.Dimension(1000, 600));
        jPanelMapa.setOpaque(false);
        jPanelMapa.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelMapa.setLayout(null);

        jLabelMapaAmbiente.setFont(new java.awt.Font("Noto Sans", 1, 24)); // NOI18N
        jLabelMapaAmbiente.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelMapaAmbiente.setAlignmentY(0.0F);
        jLabelMapaAmbiente.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        jLabelMapaAmbiente.setMaximumSize(new java.awt.Dimension(1000, 600));
        jLabelMapaAmbiente.setMinimumSize(new java.awt.Dimension(1000, 600));
        jLabelMapaAmbiente.setPreferredSize(new java.awt.Dimension(1000, 600));
        jPanelMapa.add(jLabelMapaAmbiente);
        jLabelMapaAmbiente.setBounds(0, 0, 1000, 600);

        jPanelImagem.add(jPanelMapa);
        jPanelMapa.setBounds(0, 0, 1000, 600);

        add(jPanelImagem, java.awt.BorderLayout.CENTER);

        jPanelFiltros.setBackground(new java.awt.Color(187, 246, 197));
        jPanelFiltros.setPreferredSize(new java.awt.Dimension(280, 650));

        jLabelFiltroOpcoes.setFont(new java.awt.Font("Noto Sans", 1, 14)); // NOI18N
        jLabelFiltroOpcoes.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelFiltroOpcoes.setText("Exibir Filtros!!");
        jLabelFiltroOpcoes.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        jComboBoxFiltrosOpcoes.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Por AP (equipamento)", "Por BSSID (nome rede)", "Por Canal (frequencia)", "TODO: RadioButton com Intensidade ou Qualidade", " " }));
        jComboBoxFiltrosOpcoes.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxFiltrosOpcoesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelFiltrosLayout = new javax.swing.GroupLayout(jPanelFiltros);
        jPanelFiltros.setLayout(jPanelFiltrosLayout);
        jPanelFiltrosLayout.setHorizontalGroup(
            jPanelFiltrosLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelFiltrosLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabelFiltroOpcoes, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(jPanelFiltrosLayout.createSequentialGroup()
                .addGap(33, 33, 33)
                .addComponent(jComboBoxFiltrosOpcoes, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanelFiltrosLayout.setVerticalGroup(
            jPanelFiltrosLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelFiltrosLayout.createSequentialGroup()
                .addGap(33, 33, 33)
                .addComponent(jLabelFiltroOpcoes, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jComboBoxFiltrosOpcoes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        add(jPanelFiltros, java.awt.BorderLayout.EAST);

        jPanelBotoes.setBackground(new java.awt.Color(255, 109, 0));
        jPanelBotoes.setPreferredSize(new java.awt.Dimension(1280, 120));

        jButtonSave.setText("Save Status");
        jButtonSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSaveActionPerformed(evt);
            }
        });

        jButtonAbort.setText("Cancel Project");
        jButtonAbort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAbortActionPerformed(evt);
            }
        });

        jButtonAddMap.setText("Add New Map");
        jButtonAddMap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddMapActionPerformed(evt);
            }
        });

        jButtonFinishProject.setText("Finish Project");
        jButtonFinishProject.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonFinishProjectActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelBotoesLayout = new javax.swing.GroupLayout(jPanelBotoes);
        jPanelBotoes.setLayout(jPanelBotoesLayout);
        jPanelBotoesLayout.setHorizontalGroup(
            jPanelBotoesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelBotoesLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButtonAddMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButtonSave)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 899, Short.MAX_VALUE)
                .addComponent(jButtonAbort)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButtonFinishProject)
                .addContainerGap())
        );
        jPanelBotoesLayout.setVerticalGroup(
            jPanelBotoesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelBotoesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelBotoesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonAbort)
                    .addComponent(jButtonSave)
                    .addComponent(jButtonAddMap)
                    .addComponent(jButtonFinishProject))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        add(jPanelBotoes, java.awt.BorderLayout.SOUTH);
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSaveActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jButtonSaveActionPerformed

    private void jButtonAbortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAbortActionPerformed
        // TODO add your handling code here:
        getPai().showPainelInicial();
    }//GEN-LAST:event_jButtonAbortActionPerformed

    private void jButtonAddMapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddMapActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jButtonAddMapActionPerformed

    private void jButtonFinishProjectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonFinishProjectActionPerformed
        // TODO add your handling code here:

    }//GEN-LAST:event_jButtonFinishProjectActionPerformed

    private void jComboBoxFiltrosOpcoesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBoxFiltrosOpcoesActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jComboBoxFiltrosOpcoesActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAbort;
    private javax.swing.JButton jButtonAddMap;
    private javax.swing.JButton jButtonFinishProject;
    private javax.swing.JButton jButtonSave;
    private javax.swing.JComboBox<String> jComboBoxFiltrosOpcoes;
    private javax.swing.JLabel jLabelFiltroOpcoes;
    private javax.swing.JLabel jLabelHeatmap;
    private javax.swing.JLabel jLabelMapaAmbiente;
    private javax.swing.JLabel jLabelPontos;
    private javax.swing.JPanel jPanelBotoes;
    private javax.swing.JPanel jPanelDesenhaPontos;
    private javax.swing.JPanel jPanelFiltros;
    private javax.swing.JPanel jPanelHeatMap;
    private javax.swing.JPanel jPanelImagem;
    private javax.swing.JPanel jPanelMapa;
    // End of variables declaration//GEN-END:variables

    private JPanelMeuEstilo jPanelDesenhaPontos2;
    
    /*
    @Override
    public void paintComponent(Graphics g) { //sobrescreve metodo existente do JComponent
        super.paintComponent(g); //pinta painel principal
        //talvez seja necessário sobrescrever não o paintComponente do JPanel, mas o paintComponente do JLabel
        jLabelImagem.paintComponents(g); //pinta a imagem
        mapa.paintMapa(this.getGraphics()); //pinta overlay
    }
    *//*
    private class ImagemMapa extends JLabel{
        @Override
        public void paintComponent(Graphics g) { //sobrescreve metodo existente do JComponent
            //talvez seja necessário sobrescrever não o paintComponente do JPanel, mas o paintComponente do JLabel
            this.paintComponents(g); //pinta a imagem
            mapa.paintMapa(this.getGraphics()); //pinta overlay
        }      
    }
*/
    
    @Override
    public void paintComponents(Graphics g) {
        super.paintComponents(g);
    }


    
    
    protected PainelProjeto getPainelProjeto() {
        return this;
    }
    
    public String runCommandOnTerminal(String cmd) throws IOException {
            
            final Vector<String> commands;
            //Se der ruim voltar como era new Vector<String>();
            commands = new Vector<>();
            commands.add("/bin/bash");
            commands.add("-c");
            commands.add(cmd);
            
            BufferedReader br = null;
            StringBuffer saida = new StringBuffer();
            
            try {
                final ProcessBuilder p = new ProcessBuilder(commands);
                final Process proc = p.start();
                final InputStream is = proc.getInputStream();
                final InputStreamReader isr = new InputStreamReader(is);
                br = new BufferedReader(isr);
                
                String line;
                while ((line = br.readLine()) != null) {
                    
                    saida.append(line+"\n");
                    //System.out.println(line);
                    //Thread.sleep(200);
                    //System.out.println(/*"[" +*/ line /*+ "]"*/);
                }
                
                // força a espera pelo término do processo
                proc.waitFor();
                
            } catch (IOException ioe) {
                System.err.println(ioe);
                return System.err.toString();
            }
            finally {
                secureClose(br);
                
                return saida.toString();
            }
            
            
    }
    
    private void secureClose(final Closeable resourse) {
            try {
                if (resourse != null) {
                    resourse.close();
                }                
            } catch (IOException ex) {
                System.err.println(ex);
            }
    }
    
    private class AtualizadorPontosMedicao implements Runnable{

        @Override
        public void run() {

            while( PROGRAMA_EXECUTANDO ){
                try{

                    if(ATUALIZA && !listPontos.isEmpty()){
                        try{
                            desenhaPontosViaAWT();
                            //System.out.print(".");
                        }catch(Exception e){}
                    }
                    
                    Thread.sleep(200);
                    //Thread.yield();

                } catch (Exception ex) {
                    Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            
        }//run
        
        public void desenhaPontosViaGNUPlot(){
            try {
                String saidaGnuPlot = runCommandOnTerminal("sh filtra-saida-gnuplot.sh \'"+ arquivoCaptura.getName() + "\' ");
                //System.out.println("saida_.txt ==> dados-cell.txt");

                GnuPlotComandos.plotPontosMedicao();
                //System.out.println("pontos_medicao.png plotted");

                String corta = runCommandOnTerminal("/usr/bin/convert ./cache/pontos_medicao.png -crop 1000x600+175+80 ./cache/pontos.png");
                //System.out.println("pontos.png cropped: "+corta);
            } catch (IOException ex) {
                Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
            }

            try {
                //if( filtroIntensidade )
                jLabelPontos.setIcon(new javax.swing.ImageIcon("./cache/pontos.png")); 
                //else if( filtroQualidade )
                //   jLabelHeatmap.setIcon(new javax.swing.ImageIcon(getClass().getResource("/cache/heatmap_qualidade.png"))); 

                jLabelPontos.repaint();

                //System.out.println("jLabelPontos updated");
            } catch (Exception ex) {
                Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        public void desenhaPontosViaAWT() {
        
            if (!ATUALIZA || inicio || listPontos.isEmpty()) {
                //System.out.println("inicio!!!");
                return;
            }

            int x = 0;
            int y = 1;

            //JComponent ondeDesenhar = jPanelHeatMap;
            //JComponent ondeDesenhar = jLabelHeatmap;
            JComponent ondeDesenhar = jLabelMapaAmbiente;/*{
                public void repaint() {
                    repaint(0, 0, 0, width, height);
                }
            };*/

            Graphics g = ondeDesenhar.getGraphics();
            Graphics2D g2d = (Graphics2D) g.create();



            listPontos.forEach((ponto) -> {
                if (Arrays.equals(ponto, listPontos.get(0))) {
                    xAnterior = listPontos.get(0)[x];
                    yAnterior = listPontos.get(0)[y];

                    g.setColor(Color.RED);
                    g.fillOval(listPontos.get(0)[x]-5, listPontos.get(0)[y]-5, 10, 10);

                    ondeDesenhar.paintComponents(g);

                }else{

                    g.setColor(Color.GREEN);
                    g.fillOval(ponto[x]-5, ponto[y]-5, 10, 10);
                    g2d.setColor(Color.GREEN);
                    Stroke stroke = new BasicStroke(5);
                    g2d.setStroke(stroke);
                    g2d.drawLine(ponto[x], ponto[y], xAnterior, yAnterior);

                    xAnterior = ponto[x];
                    yAnterior = ponto[y];

                    ondeDesenhar.paintComponents(g);
                    ondeDesenhar.paintComponents(g2d);

                }
            }); //for

            ondeDesenhar.validate();
            
            //System.out.println("Desenhou os pontos!!!!");
            g2d.dispose();


        }
        
    }
    
    private class AtualizadorHeatmap implements Runnable{

        @Override
        public void run() {
            
            while(PROGRAMA_EXECUTANDO){
                
                if(ATUALIZA && listPontos.size() >= 1){
                    long t0 = System.currentTimeMillis();
                    atualizaHeatmapViaGNUPlot();
                    long t1 = System.currentTimeMillis();
                    INTERVALO_ATUALIZACAO = t1 - t0;
                    System.out.println("\t\t Heatmap gerado em " + INTERVALO_ATUALIZACAO/1000.0 + " segundos");
                    
                }
                
                try {
                    Thread.sleep(INTERVALO_ATUALIZACAO);
                } catch (InterruptedException ex) {}
            }
            
        }
        
        public void atualizaHeatmapViaGNUPlot(){
            
            if(arquivoCaptura == null)
                return;
            
            String tipoFiltro = "ESSID";
            String valorFiltro = "wifi-alunos";
            
            try {
                String saidaGnuPlot = runCommandOnTerminal("sh filtra-saida-gnuplot.sh \'"+ arquivoCaptura.getName() + "\' " + tipoFiltro+" \'"+valorFiltro+"\'");
                //System.out.println("saida_.txt ==> dados-cell.txt"); // adicionar o nome do filtro no fim do arquivo para diferenciar
                
                GnuPlotComandos.plotHeatMapIntensidade();
                //System.out.println("heatmap_intensidade.png plotted");
                
                String corta = runCommandOnTerminal("/usr/bin/convert ./cache/heatmap_intensidade.png -crop 1000x600+200+100 -flip ./cache/heatmap.png");
                //System.out.println("heatmap.png cropped: "+corta);
            } catch (IOException ex) {
                Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
            }

            //if( filtroIntensidade )
            jLabelHeatmap.setIcon(new javax.swing.ImageIcon("./cache/heatmap.png")); 
            //else if( filtroQualidade )
            //   jLabelHeatmap.setIcon(new javax.swing.ImageIcon(getClass().getResource("/cache/heatmap_qualidade.png"))); 

            //jLabelHeatmap.repaint();
            jLabelHeatmap.validate();

            //System.out.println("jLabelHeatmap updated");

        }
        
        /*
        public void atualizaHeatmapViaAWT(){
            Color[] cores = HeatMapPanel.createGradient((int)Math.pow(2,16)); //2, 4, 8, 16 bits of color

            int SIZE = HeatMapPanel.HEIGHT*HeatMapPanel.WIDTH/1000;
            
            Color cor;
            cor = HeatMapPanel.minhaCor;

            
            //HeatMapPanel heatMap = new HeatMapPanel(HeatMapPanel.generateSinCosData(SIZE), true, cores );
            HeatMapPanel heatMap;
            heatMap = new HeatMapPanel(HeatMapPanel.generateRampTestData(SIZE), true, cores );
            //HeatMapPanel heatMap = new HeatMapPanel(HeatMapPanel.generateRandomTestData(SIZE), true, cores );
            //HeatMapPanel heatMap = new HeatMapPanel(HeatMapPanel.generatePyramidData(SIZE), true, cores );
            heatMap.setOpaque(true);
            heatMap.setColorBackground(cor);
            //System.out.println("posicao mouse label: " + "x:" + x + " y:" + y);
        }
        */
        
    }
    
    protected String executaIwList(String interfaceWireless/* opcoes de filtro na medicao : , ponto de acesso, rede */) {

        String retornoIwlist="";
        String[] iw = interfaceWireless.split("\n");
        final String CMD_IWLIST_SCAN = "sudo iwlist "+iw[0]+" scanning | " + "grep -E \"(Cell)|(Channel)|(Frequency)|(Quality)|(ESSID)\"";
        try {
            retornoIwlist = runCommandOnTerminal(CMD_IWLIST_SCAN);
        } catch (IOException ex) {
            System.out.println(ex);
            Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
        }

        return retornoIwlist;
    }
    
    private long TIMESTAMP_ULTIMA_MEDICAO = 0;
    private String INTERFACE_IW_DEV = null;
    protected void realizaMedicao(int x, int y){
    //DICA: ao abrir o programa, apresentar ao usuário um Combobox com as opções de interface wireless
            //disparar bash aqui
            
            if(INTERFACE_IW_DEV == null){
                final String CMD_GET_WIRELESS_INTERFACE = "iw dev | grep 'Interface' | awk '{print $2}' ";
                
                //System.out.print("wireless interface: "); 
                
                
                try {
                    INTERFACE_IW_DEV = runCommandOnTerminal(CMD_GET_WIRELESS_INTERFACE);
                } catch (IOException ex) {
                    Logger.getLogger(PainelProjeto.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            //System.out.println(INTERFACE_IW_DEV);
            long t0 = System.currentTimeMillis();
                String saidaMedicao = executaIwList(INTERFACE_IW_DEV);
            long t1 = System.currentTimeMillis();
            TIMESTAMP_ULTIMA_MEDICAO = t1;
            
            INTERVALO_MEDICAO = t1 - t0; 
            System.out.println("INFO: " + INTERVALO_MEDICAO/1000.0 + " segundos " + " gastos na medição (x="+x+",y="+y+")");
            
            //TODO: poderia descartar a medição se ela for exatamente igual à 
            // anterior E o x2,y2 for muito proximo do x1,y1, talvez deixando 
            //o GNUPlot mais leve
            
            if(manipuladorArquivoMedicoes == null){
                jButtonAddMap.doClick();
            }
            else
                manipuladorArquivoMedicoes.incluiNovaMedicaoNoArquivo(x, y, saidaMedicao);
            
    }
    
    public int getLarguraPlot(){
            return jLabelMapaAmbiente.getIcon().getIconWidth();
    }

    public int getAlturaPlot(){
        return jLabelMapaAmbiente.getIcon().getIconHeight();
    }
    
    private class ArquivoMedicoesHandler{
        
        private BufferedWriter bw;
        
        public ArquivoMedicoesHandler(File novaPlantaBaixa) throws IOException{
            abreArquivoMedicoes(novaPlantaBaixa);
        }
        
        public final void abreArquivoMedicoes(File plantaBaixa) throws IOException{
            //String nomeArquivo = "saida_"/* + data.get(Calendar.YEAR) + "-" + + data.get(Calendar.MONTH) + "-" + + data.get(Calendar.DAY_OF_MONTH) */+ ".txt";
            //String nomeArquivo = "saida_" + System.currentTimeMillis()/1000;
            String nomePlanta = plantaBaixa.getName().replaceAll(" ", "_");
            String nomeArquivo = "saida_" + nomePlanta + ".txt";

            arquivoCaptura = new File(nomeArquivo);
            arquivoCaptura.createNewFile();//se existir não recria
            
            if(arquivoCaptura.exists()){
                bw = new BufferedWriter( new FileWriter( arquivoCaptura, true ) );
            }else{
                bw = new BufferedWriter( new FileWriter( arquivoCaptura ) );
            }
            
        }
        
        public void incluiNovaMedicaoNoArquivo(int x, int y, String saidaMedicao){
            try{
                bw.write("POSICAO_MEDIDA "  + x + " " + y + "\n");
		System.out.println("(x="+x+",y="+y+") iwlist retornou " + saidaMedicao.length() + " linhas");
                /*
                System.out.println("ARQUIVO GERADO: \n"
                        + interfaces+"posicao: " + "x:" + x + " y:" + y + "\n"
                        + saidaMedicao + "\n_____________FIM ARQUIVO GERADO______________\n\n");
                */
                bw.write(saidaMedicao);
                //quebra de linha
                bw.newLine();
		bw.flush();
                //enquanto houver mais linhas
            }
            catch(IOException e){
                System.err.println("ATENÇÃO: Falha ao gravar esta última medição :(");
            }
        }
        
        public void fechaArquivoMedicao(){
            try {
                bw.flush();
            } catch (IOException ex) {
                System.err.println("ATENÇÃO: Falha ao gravar as últimas medições :O");
            }
            secureClose(bw);
        }
    }
    
    private class MouseTratadorClique extends MouseAdapter {
    
        @Override
        public void mouseClicked(MouseEvent e) {
            PainelProjeto.inicio=false;
            
            if( (System.currentTimeMillis() - TIMESTAMP_ULTIMA_MEDICAO) < INTERVALO_MEDICAO ){
                System.err.println("WARN:\t aguarde a medição anterior terminar antes de clicar novamente!" );
                return;
            }
            
            int x = e.getX();
            int y = e.getY();
            listPontos.add( new Integer[]{x,y} );
            
            realizaMedicao(x,y);
            
            //getPainelProjeto().validate();
            
            
            // UPDATE PONTOS MEDICAO via Thread
            /*new AtualizadorPontosMedicao().desenhaPontosViaGNUPlot();*/
            /*new AtualizadorPontosMedicao().desenhaPontosViaAWT();*/
                        
        }
        
    }
    
    
    private class FileOpenListener implements ActionListener {

        private BufferedImage overlayPontos;//buffer
        
        public BufferedImage getImagemPontos(){
            return this.overlayPontos;
        }
        
        //private PainelProjeto painelPai;

        public FileOpenListener(PainelProjeto painelPai) {
            //this.painelPai = painelPai;
            overlayPontos = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_ARGB);// cria um buffer com o tamanho e o tipo definido, outro tipo comum BufferedImage.TYPE_INT_RGB
            
        }
        
        

        private FileOpenListener() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        /*
        public void paintMapa(Graphics g) {
            g.setColor(Color.BLUE); //seleciona cor de fundo
            g.fillRect(0, 0, overlayPontos.getWidth(), overlayPontos.getHeight());//pinta tudo com a cor selecionada
            g.drawImage(overlayPontos, 0, 0, null); // pinta o jpanel com o buffer
            g.dispose();
        }

        private void pinta(int x, int y) {
            Graphics gDoBuffer = overlayPontos.createGraphics();//pega o graphics do buffer para edicao
            gDoBuffer.setColor(Color.ORANGE); //seta a cor do pincel
            gDoBuffer.fillRect(x, y, 10, 10); //desenha um ponto
            gDoBuffer.dispose();
            updateUI();//atualiza o jpanel, ou seja, "diz ao jpanel q seu desenho foi atualizado e vc qé q seja exibido"
        }
        */
        
        

        @Override
        public void actionPerformed(ActionEvent event) {
            chooser.setCurrentDirectory(new File("."));
            int result = chooser.showOpenDialog(getPai());
            
            if (result == JFileChooser.APPROVE_OPTION) {
                String caminhoCompletoImagem = chooser.getSelectedFile().getPath();
                
                ImageIcon icon = new ImageIcon(caminhoCompletoImagem);
                Image imagemPlantaBaixa = icon.getImage();
                //Image newimg = image.getScaledInstance(DEFAULT_WIDTH, DEFAULT_HEIGHT, java.awt.Image.SCALE_SMOOTH);  
                //Image newimg = image.getScaledInstance( jLabelImagem.getWidth(), jLabelImagem.getHeight(), java.awt.Image.SCALE_SMOOTH);  
                Image imagemPlantaBaixaReescalada = tamanhoImagem(imagemPlantaBaixa);
                ImageIcon iconReescalado = new ImageIcon(imagemPlantaBaixaReescalada);
                
                jLabelMapaAmbiente.setIcon(iconReescalado);
                //label.setIcon( new ImageIcon( name ));

                //guardar num arquivo texto o caminho da imagem e suas dimensoes
                //pesquisar classe Properties (get, set), um registro extends Serializable (read and write bytes)
                System.out.println(jLabelMapaAmbiente.getIcon().getIconWidth() + " x " + jLabelMapaAmbiente.getIcon().getIconHeight());
            
                try {
                    
                    if(manipuladorArquivoMedicoes != null)
                        manipuladorArquivoMedicoes.fechaArquivoMedicao();
                    else
                        manipuladorArquivoMedicoes = new ArquivoMedicoesHandler( new File(caminhoCompletoImagem) );
                    
                    jLabelMapaAmbiente.setVisible(true);
                    ATUALIZA = true;
                } catch (IOException ex) {
                    System.err.println("ERRO: não foi possível criar o arquivo que salvaria as medições. Abortando...");
                    jLabelMapaAmbiente.setVisible(false);
                }
            }
        }

        public Image tamanhoImagem(Image image) {

            return image.getScaledInstance(jLabelMapaAmbiente.getWidth(), jLabelMapaAmbiente.getHeight(), java.awt.Image.SCALE_SMOOTH);
        }

        
    }

    class ExtensionFileFilter extends FileFilter {

        public void addExtension(String extension) {
            if (!extension.startsWith(".")) {
                extension = "." + extension;
            }
            extensions.add(extension.toLowerCase());
        }

        public void setDescription(String aDescription) {
            description = aDescription;
        }
        
        @Override
        public String getDescription() {
            return description;
        }

        @Override
        public boolean accept(File f) {
            if (f.isDirectory()) {
                return true;
            }
            String name = f.getName().toLowerCase();
            
            return extensions.stream().anyMatch((extension) -> (name.endsWith(extension)));
        }
        private String description = "";
        //tirar final e voltar Vector<String>
        private final Vector<String> extensions = new Vector<>();
    }

    class FileIconView extends FileView {

        public FileIconView(FileFilter aFilter, Icon anIcon) {
            filter = aFilter;
            icon = anIcon;
        }
        
        @Override
        public Icon getIcon(File f) {
            if (!f.isDirectory() && filter.accept(f)) {
                return icon;
            } else {
                return null;
            }
        }
        
        private final FileFilter filter;
        private final Icon icon;
    }

    class ImagePreviewer extends JLabel {
        public ImagePreviewer(JFileChooser chooser) {
            setPreferredSize(new Dimension(100, 100));
            setBorder(BorderFactory.createEtchedBorder());
            chooser.addPropertyChangeListener((PropertyChangeEvent event) -> {
                if (event.getPropertyName() == null ? JFileChooser.SELECTED_FILE_CHANGED_PROPERTY == null : event.getPropertyName().equals(JFileChooser.SELECTED_FILE_CHANGED_PROPERTY)) {
                    File f = (File) event.getNewValue();
                    if (f == null) {
                        setIcon(null);
                        return;
                    }
                    ImageIcon icon = new ImageIcon(f.getPath());
                    if (icon.getIconWidth() > getWidth()) {
                        icon = new ImageIcon(icon.getImage().getScaledInstance(getWidth(), -1, Image.SCALE_DEFAULT));
                    }
                    
                    setIcon(icon);
                }
            });
        }
    }

}
